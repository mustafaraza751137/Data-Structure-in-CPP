@csalgo

Chapter Assignment
Problem Statement: LCA of Binary Tree
Problem Level: MEDIUM
Problem Description:
Given a binary tree and two nodes, find LCA (Lowest Common Ancestor) of the given two nodes in Binary Tree. Read about LCA if you are having doubts about the definition.
If out of 2 nodes only one node is present, return that node.
If both are not present, return -1.
Input format :
Line 1 :  Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Two integers, Node 1 and Node 2 (separated by space)

Output Format :
LCA

Constraints :
1 <= N <= 1000

Sample Input 1:
5 10 6 2 3 -1 -1 -1 -1 -1 9 -1 -1
2 10

Sample Output 1:
10

Sample Input 2:
5 10 6 2 3 -1 -1 -1 -1 -1 9 -1 -1
2 6

Sample Output 2:
5

Sample Input 3:
5 10 6 2 3 -1 -1 -1 -1 -1 9 -1 -1
12 78

Sample Output 3:
-1



=====Answer=====
Correct Option: 

@csalgo


#include<bits/stdc++.h>
using namespace std;

template<typename T>
class TreeNode{
	public:
		T data;
		TreeNode<T>* left;
		TreeNode<T>* right;
		TreeNode(T data){
			this->data=data;
			left=NULL;
			right=NULL;
		}
		~TreeNode(){
			delete left;
			delete right;
		}
};

TreeNode<int>* takeInput(){
	int data;
	cin>>data;
	TreeNode<int>* root=new TreeNode<int>(data);
	queue<TreeNode<int>*> pendingNodes;
	pendingNodes.push(root);
	while(pendingNodes.size()!=0){
		TreeNode<int>* front=pendingNodes.front();
		pendingNodes.pop();
		cin>>data;
		if(data!=-1){
			TreeNode<int>* leftNode=new TreeNode<int>(data);
			front->left=leftNode;
			pendingNodes.push(front->left);
		}
		cin>>data;
		if(data!=-1){
			TreeNode<int>* rightNode=new TreeNode<int>(data);
			front->right=rightNode;
			pendingNodes.push(front->right);
		}
	}
	return root;
}

void printTreeWise(TreeNode<int>* root){
	if(root==NULL)
		return;
	queue<TreeNode<int>*> pendingNodes;
	pendingNodes.push(root);
	pendingNodes.push(NULL);
	while(pendingNodes.size()!=0){
		TreeNode<int>* front=pendingNodes.front();
		pendingNodes.pop();
		if(front==NULL){
			cout<<endl;
			if(pendingNodes.size()!=0)
				pendingNodes.push(NULL);
		}
		if(front!=NULL){
			cout<<front->data<<" ";
			if(front->left)
				pendingNodes.push(front->left);
			if(front->right)
				pendingNodes.push(front->right);
		}
	}
}
int LCA(TreeNode<int>* root,int n1,int n2){
	if(root==NULL)
		return -1;
	if(root->data==n1 || root->data==n2)
		return root->data;
	int l=LCA(root->left,n1,n2);
	int r=LCA(root->right,n1,n2);
	if(l!=-1 && r!=-1)
		return root->data;
	return l!=-1 ? l:r;
}

int main(){
	TreeNode<int>* root=takeInput();
	int n1,n2;
	cin>>n1>>n2;
	// cout<<"Tree: \n";
	// printTreeWise(root);
	cout<<LCA(root,n1,n2);
}